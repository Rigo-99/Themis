#!/bin/bash

BASE_LEN=24
USER_ME=$USER

show_help() {
    cat << EOF
Usage: $0 <partition>

This script summarizes the resource usage of nodes in a given SLURM partition.
It prints two tables:

  1. Node-level usage:
     - CPU and GPU usage bars
     - Red    # = your jobs
     - Yellow + = other users' jobs
     - Green  - = free resources
     - Gray   @ = non available resources
     - If total resources exceed $BASE_LEN, bars are scaled to length $BASE_LEN
       and displayed inside curly braces {} instead of square brackets [].

  2. User-level usage:
     - Number of jobs
     - Total CPUs used
     - Total GPUs used

Options:
  -h, --help    Show this help message

Summarizes CPU/GPU usage per node and per user for a SLURM partition.
EOF
    exit 0
}

# --- Parse args ---
if [[ $# -eq 0 ]]; then
    echo "Error: partition name required."
    echo "Try '$0 --help' for usage."
    exit 1
fi


if [[ $1 == "-h" || $1 == "--help" ]]; then
    show_help
fi

PARTITION=$1

# --- 1. Totals and states per node (CPU) ---
declare -A TOTAL_CPU NODE_STATE
NODES=()
MAX_CPUS=0

while read NODE CPUSSTATE; do
    NODE=${NODE%%.*}
    # CPUSSTATE looks like: allocated/idle/other...
    IFS='/' read -r ALLOC IDLE REST <<< "$CPUSSTATE"
    TOTAL=$((ALLOC + IDLE + REST))
    TOTAL_CPU[$NODE]=$TOTAL
    (( TOTAL > MAX_CPUS )) && MAX_CPUS=$TOTAL
    NODE_STATE[$NODE]="$(sinfo -N -n $NODE -o "%t" -h)"
    NODES+=("$NODE")
done < <(sinfo -p "$PARTITION" -N -O nodehost,cpusstate --noheader)

# --- GPU totals from sinfo ---
declare -A TOTAL_GPU
MAX_GPUS=0
while read NODE CPUS GRES; do
    [[ "$GRES" == "N/A" ]] && GRES=""
    GPU_COUNT=0
    if [[ $GRES =~ gpu:[A-Za-z0-9_-]*:([0-9]+) ]]; then
        GPU_COUNT=${BASH_REMATCH[1]}
    elif [[ $GRES =~ gpu:([0-9]+) ]]; then
        GPU_COUNT=${BASH_REMATCH[1]}
    fi
    TOTAL_GPU[$NODE]=$GPU_COUNT
    (( GPU_COUNT > MAX_GPUS )) && MAX_GPUS=$GPU_COUNT
done < <(sinfo -h -p "$PARTITION" -N -o "%n %c %G")

LEN_CPU=$(( MAX_CPUS <= BASE_LEN ? MAX_CPUS : BASE_LEN ))
LEN_GPU=$(( MAX_GPUS <= BASE_LEN ? MAX_GPUS : BASE_LEN ))

# --- 2. Usage from squeue (GPU logic unchanged) ---
declare -A USED_CPU USED_GPU MY_CPU MY_GPU
declare -A USER_JOBS USER_CPU USER_GPU

expand_nodes() {
    local nodelist=$1
    python3 -c "import re; import itertools; n='$nodelist';
import re
m=re.match(r'([^[]+)\[([^\]]+)\]', n)
if not m: print(n); exit()
prefix, inner=m.groups()
parts=[]
for group in inner.split(','):
    if '-' in group:
        a,b=group.split('-')
        a,b=int(a),int(b)
        width=len(group.split('-')[0])
        for i in range(a,b+1): parts.append(f'{prefix}{i:0{width}d}')
    else:
        parts.append(f'{prefix}{group}')
print('\n'.join(parts))"
}

while read JOBID USER CPU GRES NODESTR; do
    [[ -z "$NODESTR" || "$NODESTR" == "(null)" ]] && continue
    GPU=0
    if [[ $GRES != "N/A" && $GRES =~ gpu:([0-9]+) ]]; then
        GPU=${BASH_REMATCH[1]}
    fi

    NODES_LIST=($(expand_nodes "$NODESTR"))
    N_NODES=${#NODES_LIST[@]}

    CPU_PER_NODE=$((CPU / N_NODES))
    GPU_PER_NODE=$((GPU / N_NODES))

    if (( N_NODES > 1 )); then
        SINFO=$(scontrol show job "$JOBID" 2>/dev/null)
        if [[ $SINFO =~ TresPerNode=([^[:space:]]+) ]]; then
            TRES=${BASH_REMATCH[1]}
            [[ $TRES =~ cpu:([0-9]+) ]] && CPU_PER_NODE=${BASH_REMATCH[1]}
            [[ $TRES =~ gpu:([0-9]+) ]] && GPU_PER_NODE=${BASH_REMATCH[1]}
        fi
    fi

    for N in "${NODES_LIST[@]}"; do
        USED_CPU[$N]=$(( ${USED_CPU[$N]:-0} + CPU_PER_NODE ))
        USED_GPU[$N]=$(( ${USED_GPU[$N]:-0} + GPU_PER_NODE ))
        if [[ $USER == $USER_ME ]]; then
            MY_CPU[$N]=$(( ${MY_CPU[$N]:-0} + CPU_PER_NODE ))
            MY_GPU[$N]=$(( ${MY_GPU[$N]:-0} + GPU_PER_NODE ))
        fi
    done

    USER_JOBS[$USER]=$(( ${USER_JOBS[$USER]:-0} + 1 ))
    USER_CPU[$USER]=$(( ${USER_CPU[$USER]:-0} + CPU ))
    USER_GPU[$USER]=$(( ${USER_GPU[$USER]:-0} + GPU ))

done < <(squeue -h -p "$PARTITION" -o "%A %u %C %b %R")

# --- 3. Progress bar (new rounding logic) ---
progress_bar() {
    local mine=$1 others=$2 total=$3 length=$4 base_len=$5 gray=${6:-0}
    local used=$((mine + others))
    local mine_len others_len free_len

    if (( total > 0 )); then
        mine_len=$(awk -v m=$mine -v l=$length -v t=$total 'BEGIN{v=m*l/t; printf("%d",(v>0 && v<1)?1:int(v+0.5))}')
        others_len=$(awk -v o=$others -v l=$length -v t=$total 'BEGIN{v=o*l/t; printf("%d",(v>0 && v<1)?1:int(v+0.5))}')
        free_len=$((length - mine_len - others_len))
        (( free_len < 0 )) && free_len=0
    else
        free_len=$length
    fi

    local percent=0
    (( total > 0 )) && percent=$((100 * used / total))

    local open="[" close="]"
    (( total > base_len )) && open="{" && close="}"

    echo -ne "$open"
    if (( gray )); then
        echo -ne "\033[90m$(printf "%0.s@" $(seq 1 $length))\033[0m"
    else
        (( mine_len > 0 )) && echo -ne "\033[31m$(printf "%0.s#" $(seq 1 $mine_len))"
        (( others_len > 0 )) && echo -ne "\033[33m$(printf "%0.s+" $(seq 1 $others_len))"
        (( free_len > 0 )) && echo -ne "\033[32m$(printf "%0.s-" $(seq 1 $free_len))"
        echo -ne "\033[0m"
    fi

    # ðŸ”§ usa printf qui per stampare la percentuale correttamente
    printf "$close %3d%%" "$percent"
}


# --- 4. Node table ---
CPU_COL=$((LEN_CPU+17))
GPU_COL=$((LEN_GPU+17))

printf "\n=== NODES in partition %s ===\n\n" "$PARTITION"
printf "%-15s | %-*s | %-*s\n" "NODE" $CPU_COL "CPU usage" $GPU_COL "GPU usage"
printf "%s+%s+%s\n" \
       "$(printf '%0.s-' $(seq 1 16))" \
       "$(printf '%0.s-' $(seq 1 $((CPU_COL+2))))" \
       "$(printf '%0.s-' $(seq 1 $((GPU_COL+2))))"

for NODE in $(printf "%s\n" "${NODES[@]}" | sort); do
    CPUS=${TOTAL_CPU[$NODE]:-0}
    NGPU=${TOTAL_GPU[$NODE]:-0}
    ALL_CPUS=${USED_CPU[$NODE]:-0}
    ALL_GPUS=${USED_GPU[$NODE]:-0}
    MYC=${MY_CPU[$NODE]:-0}
    MYG=${MY_GPU[$NODE]:-0}
    OTHERS_CPUS=$((ALL_CPUS - MYC))
    OTHERS_GPUS=$((ALL_GPUS - MYG))

    STATE=${NODE_STATE[$NODE]}
    GRAY=0
    [[ $STATE =~ drain|fail|down|unknown ]] && GRAY=1

    printf "%-15s | " "$NODE"
    progress_bar $MYC $OTHERS_CPUS $CPUS $LEN_CPU $BASE_LEN $GRAY
    printf " (%3d/%-3d) | " "$ALL_CPUS" "$CPUS"
    if (( NGPU > 0 )); then
        progress_bar $MYG $OTHERS_GPUS $NGPU $LEN_GPU $BASE_LEN $GRAY
        printf " (%3d/%-3d)\n" "$ALL_GPUS" "$NGPU"
    else
        printf "\n"
    fi
done

# --- 5. User table ---
printf "\n\n=== USERS active in partition %s ===\n\n" "$PARTITION"
printf "%-15s | %-6s | %-8s | %-8s\n" "USER" "N_JOBS" "TOT_CPUS" "TOT_GPUS"
printf "%s+%s+%s+%s\n" \
       "$(printf '%0.s-' $(seq 1 16))" \
       "$(printf '%0.s-' $(seq 1 8))" \
       "$(printf '%0.s-' $(seq 1 10))" \
       "$(printf '%0.s-' $(seq 1 10))"

for U in $(printf "%s\n" "${!USER_JOBS[@]}" | sort); do
    printf "%-15s | %6d | %8d | %8d\n" \
        "$U" "${USER_JOBS[$U]}" "${USER_CPU[$U]}" "${USER_GPU[$U]}"
done
